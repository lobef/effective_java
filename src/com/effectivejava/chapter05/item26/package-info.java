/**
 * 本节学习请不要使用原生态类型
 * 1.基本定义
 * 泛型类或者接口：声明中具有一个或者多个类型参数的类或者接口，如List<E>
 * 参数化类型：泛型中的尖括号中的实际类型，如List<String>
 * 原生态类型：不带任何实际类型参数的泛型名称，如List list = new ArrayList();
 * 2.使用原生态类型的弊端
 * 将错误的类型放入到集合中强转为另一个类型，在编译器不能检查出异常，而在运行期出现异常，出错最好在编译期发现。
 * 使用泛型后的集合，可以在编译期检查插入的对象的类型是否正确
 * 如果使用原生态类型，就失掉了泛型在安全性和描述性方面的所有优势。
 * 保留原生态类型，只是为了兼容以前的java平台，这就是移植兼容性
 * 3.原生态类型List与参数化类型List<Object>的区别
 * 前者逃避泛型检查，后者则明确告知编译器，它能够持有任意类型的对象
 * 泛型有子类化，List<String>是原生态类型List的子类，所以能够赋值，但是List<String>不是List<Object>子类所以不能赋值
 * 如果使用像List的原生态类型，就会失掉类型安全性，但是如果使用像List<Object>这样的参数化类型，则不会
 * 4.不确定或者不在乎集合中的元素怎么办
 * 1）可能使用原生态类型，这种做法很危险
 * 2）无限制的通配符类型。使用泛型，但是尖括号中是一个问号，这个问号表示不确定或者不关心实际的类型参数
 * 5.不能将任何元素放到Collection<?>，null除外，防止破坏集合的类型约束条件
 * 解决这种问题时，需要使用泛型方法或者有限制的通配符类型
 * 6.需要使用原生态类型的情况
 * 1）必须在类文字中使用原生态类型，如List.class,String[].class,int.class都是合法的，
 * 但是List<String>.class,List<?>.class则不可以
 * 2）与instanceof操作符有关，在使用instanceof时，可以使用如List<?>或者List，但是使用如List<String>则不可以
 * 总结：使用原生态类型会在运行时导致异常，不推荐使用，原生态类型只在为了兼容以前
 * 
 * 
 * 
 */
package com.effectivejava.chapter05.item26;