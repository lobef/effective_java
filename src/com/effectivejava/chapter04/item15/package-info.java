/**
 * 本节讲述使可变性最小化
 * 1.不可变类的存在理由
 * 不可变类比可变类更加易于设计、实现和使用，不易出错，更加安全
 * 2.使类不可变需要遵循的五大规则
 * 1）不要提供任何会修改对象的状态的方法（mutator）
 * 2）保证类不会被扩展，
 * ①一般使用final修饰这个类，这样能够保证不被子类化，
 * ②让类的所有构造器变为私有的或者包级私有，同时添加公有的静态工厂创建对象
 * 3）所有的域都是final的。在缺乏同步机制的情况下，可以保证实例对象从一个线程到另一个线程状态的正确性
 * 4）使所有的域都是私有的，阻止客户端修改对象，也阻止客户端访问对象中引用可变对象的权限，
 * 5）确保对于任何可变组件的互斥访问。
 * ①如果类具有指向可变对象的域，则必须确保该类不被客户端获得指向这些对象的引用；
 * ②不能使用客户端提供的对象初始化类中可变对象域，也不要从任何方法中返回类中可变对象的引用
 * ③在构造器、访问方法和readObject方法中请使用保护性拷贝技术
 * 3.不可变对象的优缺点
 * 1）优点
 * ①不可变对象比较简单，不需要额外的精力去维护类的约束关系，因为类的整个生命周期内都不会变化
 * ②不可变对象本质上是线程安全的，它们不需要同步，可以自由的共享。
 * 注意：基于此优势，客户端尽可能重用现有的实例，再有就是使用静态工厂方法，将频繁创建的对象缓存起来，达到对象重用的目的
 * ③不仅可以共享不可变对象，甚至也可以共享它们的内部信息（如BigInteger）
 * ④不可变对象为其他对象提供大量的构件，如果map的中key和集合中的元素等
 * ⑤不可变对象无偿地提供了失败的原子性。状态不会改变，不存在状态不一致的情况
 * 2）缺点
 * 对于每个不同的值都需要一个单独的对象，创建这些对象的代价可能很高
 * 4.其他说明
 * 没有一个方法能够对对象的状态产生外部可见的改变。特此说明：有些不可变的类中存在一个或者多个非final的缓存域，将一些开销昂贵的计算结果缓存起来，再进行计算结果是相同的
 * 5.有关序列化的告诫
 * 如果不可变类实现Serializable接口，并且它包括一个或者多个指向可变对象的域，就必须提供一个显式的readObject或者readResolve方法或者使用ObjectOutputStream.writeUnshared和ObjectInputStream.readUnshared方法
 * 这样做的目的是增加安全性，防止攻击者可能从不可变对象的类创建可变的实例。
 * 6.某些类不可变性是不切实际的，但是仍然应该尽可能地限制他的可变性
 * 
 * 
 * 注：构造器应该创建完全初始化的对象，并建立起所有的约束关系，不要再构造器或者静态工厂之外提供公有的初始化方法，也不能提供重新初始化
 * 
 * 
 * 
 */
package com.effectivejava.chapter04.item15;